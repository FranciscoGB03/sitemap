{"ast":null,"code":"'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar inherits = require('util').inherits;\n\nvar DeferredLevelDOWN = require('deferred-leveldown');\n\nvar IteratorStream = require('level-iterator-stream');\n\nvar Batch = require('./batch');\n\nvar errors = require('level-errors');\n\nvar supports = require('level-supports');\n\nvar catering = require('catering');\n\nvar getCallback = require('./common').getCallback;\n\nvar getOptions = require('./common').getOptions; // TODO: after we drop node 10, also use queueMicrotask() in node\n\n\nvar nextTick = require('./next-tick');\n\nvar WriteError = errors.WriteError;\nvar ReadError = errors.ReadError;\nvar NotFoundError = errors.NotFoundError;\nvar OpenError = errors.OpenError;\nvar InitializationError = errors.InitializationError; // Possible AbstractLevelDOWN#status values:\n//  - 'new'     - newly created, not opened or closed\n//  - 'opening' - waiting for the database to be opened, post open()\n//  - 'open'    - successfully opened the database, available for use\n//  - 'closing' - waiting for the database to be closed, post close()\n//  - 'closed'  - database has been successfully closed, should not be\n//                 used except for another open() operation\n\nfunction LevelUP(db, options, callback) {\n  var _this = this;\n\n  if (!(this instanceof LevelUP)) {\n    return new LevelUP(db, options, callback);\n  }\n\n  var error;\n  EventEmitter.call(this);\n  this.setMaxListeners(Infinity);\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  if (!db || typeof db !== 'object') {\n    error = new InitializationError('First argument must be an abstract-leveldown compliant store');\n\n    if (typeof callback === 'function') {\n      return nextTick(callback, error);\n    }\n\n    throw error;\n  }\n\n  if (typeof db.status !== 'string') {\n    throw new Error('.status required, old abstract-leveldown');\n  }\n\n  this.options = getOptions(options);\n  this._db = db;\n  this.db = new DeferredLevelDOWN(db);\n  this.open(callback || function (err) {\n    if (err) _this.emit('error', err);\n  }); // Create manifest based on deferred-leveldown's\n\n  this.supports = supports(this.db.supports, {\n    status: false,\n    deferredOpen: true,\n    openCallback: true,\n    promises: true,\n    streams: true\n  }); // Experimental: enrich levelup interface\n\n  var _arr = Object.keys(this.supports.additionalMethods);\n\n  var _loop = function _loop() {\n    var method = _arr[_i];\n    if (_this[method] != null) return \"continue\"; // Don't do this.db[method].bind() because this.db is dynamic.\n\n    _this[method] = function () {\n      var _this$db;\n\n      return (_this$db = this.db)[method].apply(_this$db, arguments);\n    };\n  };\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var _ret = _loop();\n\n    if (_ret === \"continue\") continue;\n  }\n}\n\nLevelUP.prototype.emit = EventEmitter.prototype.emit;\nLevelUP.prototype.once = EventEmitter.prototype.once;\ninherits(LevelUP, EventEmitter);\n\nLevelUP.prototype.open = function (opts, callback) {\n  var _this2 = this;\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = null;\n  }\n\n  callback = catering.fromCallback(callback);\n\n  if (!opts) {\n    opts = this.options;\n  }\n\n  if (this.isOpen()) {\n    nextTick(callback, null, this);\n    return callback.promise;\n  }\n\n  if (this._isOpening()) {\n    this.once('open', function () {\n      callback(null, _this2);\n    });\n    return callback.promise;\n  }\n\n  this.emit('opening');\n  this.db.open(opts, function (err) {\n    if (err) {\n      return callback(new OpenError(err));\n    }\n\n    _this2.db = _this2._db;\n    callback(null, _this2);\n\n    _this2.emit('open');\n\n    _this2.emit('ready');\n  });\n  return callback.promise;\n};\n\nLevelUP.prototype.close = function (callback) {\n  var _this3 = this;\n\n  callback = catering.fromCallback(callback);\n\n  if (this.isOpen()) {\n    this.db.close(function (err) {\n      _this3.emit('closed');\n\n      for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        rest[_key - 1] = arguments[_key];\n      }\n\n      callback.apply(void 0, [err].concat(rest));\n    });\n    this.emit('closing');\n    this.db = new DeferredLevelDOWN(this._db);\n  } else if (this.isClosed()) {\n    nextTick(callback);\n  } else if (this.db.status === 'closing') {\n    this.once('closed', callback);\n  } else if (this._isOpening()) {\n    this.once('open', function () {\n      _this3.close(callback);\n    });\n  }\n\n  return callback.promise;\n};\n\nLevelUP.prototype.isOpen = function () {\n  return this.db.status === 'open';\n};\n\nLevelUP.prototype._isOpening = function () {\n  return this.db.status === 'opening';\n};\n\nLevelUP.prototype.isClosed = function () {\n  return /^clos|new/.test(this.db.status);\n};\n\nLevelUP.prototype.get = function (key, options, callback) {\n  callback = getCallback(options, callback);\n  callback = catering.fromCallback(callback);\n\n  if (maybeError(this, callback)) {\n    return callback.promise;\n  }\n\n  options = getOptions(options);\n  this.db.get(key, options, function (err, value) {\n    if (err) {\n      if (/notfound/i.test(err) || err.notFound) {\n        err = new NotFoundError('Key not found in database [' + key + ']', err);\n      } else {\n        err = new ReadError(err);\n      }\n\n      return callback(err);\n    }\n\n    callback(null, value);\n  });\n  return callback.promise;\n};\n\nLevelUP.prototype.put = function (key, value, options, callback) {\n  var _this4 = this;\n\n  callback = getCallback(options, callback);\n  callback = catering.fromCallback(callback);\n\n  if (maybeError(this, callback)) {\n    return callback.promise;\n  }\n\n  options = getOptions(options);\n  this.db.put(key, value, options, function (err) {\n    if (err) {\n      return callback(new WriteError(err));\n    }\n\n    _this4.emit('put', key, value);\n\n    callback();\n  });\n  return callback.promise;\n};\n\nLevelUP.prototype.del = function (key, options, callback) {\n  var _this5 = this;\n\n  callback = getCallback(options, callback);\n  callback = catering.fromCallback(callback);\n\n  if (maybeError(this, callback)) {\n    return callback.promise;\n  }\n\n  options = getOptions(options);\n  this.db.del(key, options, function (err) {\n    if (err) {\n      return callback(new WriteError(err));\n    }\n\n    _this5.emit('del', key);\n\n    callback();\n  });\n  return callback.promise;\n};\n\nLevelUP.prototype.batch = function (arr, options, callback) {\n  var _this6 = this;\n\n  if (!arguments.length) {\n    return new Batch(this);\n  }\n\n  if (typeof arr === 'function') callback = arr;else callback = getCallback(options, callback);\n  callback = catering.fromCallback(callback);\n\n  if (maybeError(this, callback)) {\n    return callback.promise;\n  }\n\n  options = getOptions(options);\n  this.db.batch(arr, options, function (err) {\n    if (err) {\n      return callback(new WriteError(err));\n    }\n\n    _this6.emit('batch', arr);\n\n    callback();\n  });\n  return callback.promise;\n};\n\nLevelUP.prototype.iterator = function (options) {\n  return this.db.iterator(options);\n};\n\nLevelUP.prototype.clear = function (options, callback) {\n  var _this7 = this;\n\n  callback = getCallback(options, callback);\n  options = getOptions(options);\n  callback = catering.fromCallback(callback);\n\n  if (maybeError(this, callback)) {\n    return callback.promise;\n  }\n\n  this.db.clear(options, function (err) {\n    if (err) {\n      return callback(new WriteError(err));\n    }\n\n    _this7.emit('clear', options);\n\n    callback();\n  });\n  return callback.promise;\n};\n\nLevelUP.prototype.readStream = LevelUP.prototype.createReadStream = function (options) {\n  options = Object.assign({\n    keys: true,\n    values: true\n  }, options);\n\n  if (typeof options.limit !== 'number') {\n    options.limit = -1;\n  }\n\n  return new IteratorStream(this.db.iterator(options), options);\n};\n\nLevelUP.prototype.keyStream = LevelUP.prototype.createKeyStream = function (options) {\n  return this.createReadStream(Object.assign({}, options, {\n    keys: true,\n    values: false\n  }));\n};\n\nLevelUP.prototype.valueStream = LevelUP.prototype.createValueStream = function (options) {\n  return this.createReadStream(Object.assign({}, options, {\n    keys: false,\n    values: true\n  }));\n};\n\nLevelUP.prototype.toString = function () {\n  return 'LevelUP';\n};\n\nLevelUP.prototype.type = 'levelup';\n\nfunction maybeError(db, callback) {\n  if (!db._isOpening() && !db.isOpen()) {\n    nextTick(callback, new ReadError('Database is not open'));\n    return true;\n  }\n}\n\nLevelUP.errors = errors;\nmodule.exports = LevelUP;","map":null,"metadata":{},"sourceType":"script"}