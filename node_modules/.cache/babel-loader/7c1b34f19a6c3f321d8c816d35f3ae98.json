{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\fgb_0\\\\Downloads\\\\sitemap-builder\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _awaitAsyncGenerator = require(\"C:\\\\Users\\\\fgb_0\\\\Downloads\\\\sitemap-builder\\\\node_modules\\\\@babel\\\\runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"C:\\\\Users\\\\fgb_0\\\\Downloads\\\\sitemap-builder\\\\node_modules\\\\@babel\\\\runtime/helpers/wrapAsyncGenerator\");\n\nfunction AbstractIterator(db) {\n  if (typeof db !== 'object' || db === null) {\n    throw new TypeError('First argument must be an abstract-leveldown compliant store');\n  }\n\n  this.db = db;\n  this._ended = false;\n  this._nexting = false;\n}\n\nAbstractIterator.prototype.next = function (callback) {\n  var _this = this;\n\n  // In callback mode, we return `this`\n  var ret = this;\n\n  if (callback === undefined) {\n    ret = new Promise(function (resolve, reject) {\n      callback = function callback(err, key, value) {\n        if (err) reject(err);else if (key === undefined && value === undefined) resolve();else resolve([key, value]);\n      };\n    });\n  } else if (typeof callback !== 'function') {\n    throw new Error('next() requires a callback argument');\n  }\n\n  if (this._ended) {\n    this._nextTick(callback, new Error('cannot call next() after end()'));\n\n    return ret;\n  }\n\n  if (this._nexting) {\n    this._nextTick(callback, new Error('cannot call next() before previous next() has completed'));\n\n    return ret;\n  }\n\n  this._nexting = true;\n\n  this._next(function (err) {\n    _this._nexting = false;\n\n    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      rest[_key - 1] = arguments[_key];\n    }\n\n    callback.apply(void 0, [err].concat(rest));\n  });\n\n  return ret;\n};\n\nAbstractIterator.prototype._next = function (callback) {\n  this._nextTick(callback);\n};\n\nAbstractIterator.prototype.seek = function (target) {\n  if (this._ended) {\n    throw new Error('cannot call seek() after end()');\n  }\n\n  if (this._nexting) {\n    throw new Error('cannot call seek() before next() has completed');\n  }\n\n  target = this.db._serializeKey(target);\n\n  this._seek(target);\n};\n\nAbstractIterator.prototype._seek = function (target) {};\n\nAbstractIterator.prototype.end = function (callback) {\n  var promise;\n\n  if (callback === undefined) {\n    promise = new Promise(function (resolve, reject) {\n      callback = function callback(err) {\n        if (err) reject(err);else resolve();\n      };\n    });\n  } else if (typeof callback !== 'function') {\n    throw new Error('end() requires a callback argument');\n  }\n\n  if (this._ended) {\n    this._nextTick(callback, new Error('end() already called on iterator'));\n\n    return promise;\n  }\n\n  this._ended = true;\n\n  this._end(callback);\n\n  return promise;\n};\n\nAbstractIterator.prototype._end = function (callback) {\n  this._nextTick(callback);\n};\n\nAbstractIterator.prototype[Symbol.asyncIterator] =\n/*#__PURE__*/\n_wrapAsyncGenerator(\n/*#__PURE__*/\n_regeneratorRuntime.mark(function _callee() {\n  var kv;\n  return _regeneratorRuntime.wrap(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.prev = 0;\n\n        case 1:\n          _context.next = 3;\n          return _awaitAsyncGenerator(this.next());\n\n        case 3:\n          _context.t0 = kv = _context.sent;\n          _context.t1 = undefined;\n\n          if (!(_context.t0 !== _context.t1)) {\n            _context.next = 10;\n            break;\n          }\n\n          _context.next = 8;\n          return kv;\n\n        case 8:\n          _context.next = 1;\n          break;\n\n        case 10:\n          _context.prev = 10;\n\n          if (this._ended) {\n            _context.next = 14;\n            break;\n          }\n\n          _context.next = 14;\n          return _awaitAsyncGenerator(this.end());\n\n        case 14:\n          return _context.finish(10);\n\n        case 15:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _callee, this, [[0,, 10, 15]]);\n})); // Expose browser-compatible nextTick for dependents\n\nAbstractIterator.prototype._nextTick = require('./next-tick');\nmodule.exports = AbstractIterator;","map":null,"metadata":{},"sourceType":"script"}